"use strict";(self.webpackChunknuvirlab_dev=self.webpackChunknuvirlab_dev||[]).push([[566],{1566:(e,t,r)=>{r.d(t,{pP:()=>i});var o=r(9437);function i(e,t=!1){const r=null!==e[0].index,i=new Set(Object.keys(e[0].attributes)),n=new Set(Object.keys(e[0].morphAttributes)),u={},l={},a=e[0].morphTargetsRelative,m=new o.LoY;let f=0;for(let o=0;o<e.length;++o){const s=e[o];let c=0;if(r!==(null!==s.index))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+o+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const e in s.attributes){if(!i.has(e))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+o+'. All geometries must have compatible attributes; make sure "'+e+'" attribute exists among all geometries, or in none of them.'),null;void 0===u[e]&&(u[e]=[]),u[e].push(s.attributes[e]),c++}if(c!==i.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+o+". Make sure all geometries have the same number of attributes."),null;if(a!==s.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+o+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const e in s.morphAttributes){if(!n.has(e))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+o+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===l[e]&&(l[e]=[]),l[e].push(s.morphAttributes[e])}if(t){let e;if(r)e=s.index.count;else{if(void 0===s.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+o+". The geometry must have either an index or a position attribute"),null;e=s.attributes.position.count}m.addGroup(f,e,o),f+=e}}if(r){let t=0;const r=[];for(let o=0;o<e.length;++o){const i=e[o].index;for(let e=0;e<i.count;++e)r.push(i.getX(e)+t);t+=e[o].attributes.position.count}m.setIndex(r)}for(const e in u){const t=s(u[e]);if(!t)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" attribute."),null;m.setAttribute(e,t)}for(const e in l){const t=l[e][0].length;if(0===t)break;m.morphAttributes=m.morphAttributes||{},m.morphAttributes[e]=[];for(let r=0;r<t;++r){const t=[];for(let o=0;o<l[e].length;++o)t.push(l[e][o][r]);const o=s(t);if(!o)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" morphAttribute."),null;m.morphAttributes[e].push(o)}}return m}function s(e){let t,r,i,s=-1,n=0;for(let o=0;o<e.length;++o){const u=e[o];if(void 0===t&&(t=u.array.constructor),t!==u.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===r&&(r=u.itemSize),r!==u.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===i&&(i=u.normalized),i!==u.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(-1===s&&(s=u.gpuType),s!==u.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;n+=u.count*r}const u=new t(n),l=new o.THS(u,r,i);let a=0;for(let t=0;t<e.length;++t){const o=e[t];if(o.isInterleavedBufferAttribute){const e=a/r;for(let t=0,i=o.count;t<i;t++)for(let i=0;i<r;i++){const r=o.getComponent(t,i);l.setComponent(t+e,i,r)}}else u.set(o.array,a);a+=o.count*r}return void 0!==s&&(l.gpuType=s),l}}}]);